TODO
====

 * Create a new temporal value, stored inside struct _mpdm, for literal
   strings to be found in hashes, to avoid creating over and over temporal
   values that only clobber the garbage collection.
 * Create some versions of functions that avoid doing boundary checks
   when redundant (example: calls to mpdm_aset() in mpdm_acollapse()).
 * Use the ival in hashes to store the number of elements???
 * Create a new mpdm_size() function that returns the size, to help using
   a 'deferred' strlen() calculation for non-MPDM_COPY strings.
 * Each value should have a 'destroy' pointer to a function or scripting code
   that destroys v->data. For example, a call to regfree() in compiled
   regular expressions. So, normal MPDM_FREE values could include a standard
   function that do free(v->data), MPDM_MULTIPLE another that does the
   mpdm_acollapse(), MPDM_FILE an fclose(), etc. The 'destroy' callback should
   be the first one of the 'tie'... (follows)
 * Any value could include 'tie' code, for customized operations on standard
   functions (so a hash could be mapped to a DBM on disk, etc.). The 'tie
   also scriptable' dilemma is solved with mpdm_exec(), so any code (not
   necessary a C function) could be used.
 * A new version of mpdm_asort() that includes a sorting function.
 * stat(), chmod(), bread(), bwrite().
 * Should all string values use wchar, UTF-8...?

The scripting language
----------------------

 * Find a name (mpsl?).
 * Will it be included here, or as a separated package? it could poison
   the mpdm concept as a 'low level utility library'.

Using mpdm elsewhere
--------------------

 * Of course, mp-4.
 * ahxm.

