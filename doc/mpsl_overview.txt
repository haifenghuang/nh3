Mpsl overview
=============

 Angel Ortega <angel@triptico.com>

Syntax
------

Mpsl (Minimum Profit Scripting Language) is a programming language
concieved as an scripting engine for the Minimum Profit Text Editor,
though in can also be used as a general-purpose programming tool. An mpsl
program consists of a sequence of statements which run from top to bottom.
Loops, subroutines and other control structures allow you to jump around
within the code. It is a free-form language, meaning that you can format
and indent it however you like, as whitespace serves to separate tokens.

Mpsl borrows syntax and concepts from many languages: C, Perl, Java or
JavaScript. Statements end in a semi-colon, blocks are enclosed between {
and } (curly brackets).

Comments
~~~~~~~~

Text enclosed between /* and */ is ignored, as in C. It can span multiple
lines.

Strings
~~~~~~~

Strings are enclosed around single or double quotes:

 print("This a string");
 print('This is also a string');

However, double quotes give special treatment to backslash-escaped
characters, also as in C:

 print("Hello, world\n");	/* ends with a new line */
 print('Hello, World\n');	/* prints Hello, World\n literally */

Subroutine calls
~~~~~~~~~~~~~~~~

Function and subroutine calls must enclose its arguments between
parentheses, and separated by commas:

 print("This is ", 'a list ', "of ", 5, " arguments\n");

Parentheses are needed even if a function has no arguments.

True and false
~~~~~~~~~~~~~~

The number 0, the strings '0' and '' and NULL are all false as boolean
values. Any other value is considered true.

Variables and data types
------------------------

Data types in mpsl match the mpdm (Minimum Profit Data Manager) single,
array and hash values. They are very similar to Perl ones. However,
variable names don't have a prefix indicating its type as in Perl; they
can hold any type.

Variables need not be declared (unless for local values, see below); they
are created on assignation.

Scalars
~~~~~~~

A scalar represents a single value. They can be strings, integers or
floating point numbers, and they will be converted as required.

 fruit = "pear";
 months = 12;
 pi = 3.1416;

There are other types of scalar values, as file descriptors and executable
values; they will be treated later.

Scalar assignation is always by value; by doing

 a = 100; b = a; b = 5;

The a variable still holds its original value of 100.

Arrays
~~~~~~

An array represents a list of values. Arrays are zero-indexed. Each
element of an array can be of any type (scalar, array, or hash). Array
size is dynamic and can grow or shrink at the programmer's wish.

 workdays = [ 'monday', 'tuesday', 'wednesday', 'thursday', 'friday' ];
 
 print(workdays[0], "\n");	/* prints monday */
 
 heterogeneous_array = [ 1, "string", NULL, function(), workdays ];

Array assignation is always by reference; by doing

 a = [ 10, 20, 30 ]; b = a; b[0] = 100;

The value for the element a[0] is also 100; a and b both point to the same
array. A special-purpose function, clone(), can be used if you want them
to be different values.

Arrays grow when assigned to an out-of-bounds subscript:

 ary = [ 0, 1, 2, 3 ];
 print("size: ", size(ary), "\n");	/* prints size: 4 */
 ary[100] = 100;
 print("size: ", size(ary), "\n");	/* prints size: 101 */

Hashes
~~~~~~

A hash, or associative array, represents a set of key/value pairs. Keys and
values can be of any type (scalar, array or hash). However, keys are
usually scalar values, in particular strings.

 en2es_workdays = {
	"monday"	=>	"lunes",
	"tuesday"	=>	"martes",
	"wednesday"	=>	"miércoles",
	"thursday"	=>	"jueves",
	"friday"	=>	"viernes"
	};
 
 print(en2es_workdays['monday'], "\n"); /* prints lunes */
 
 week = {
	"workdays"	=>	workdays,
	"weekend"	=>	[ 'saturday', 'sunday' ]
	};

Hash definitions *must* use the => to mark key/value pairs.

Hash assignation is always by reference, as in arrays (in fact, hashes are
just a special case of array).

Abridged access to hash members
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hashes can, and ofter are, used as records. Given the following hash of
hashes:

 app = {};
 app['config'] = {};
 app['config']['save_on_exit'] = 1;

The save_on_exit component can also be accessed by using:

 app.config.save_on_exit = 1;

Please note that variables in abridged mode are *not* automatically
created unless the path to them already exist; so 'app' and 'app.config'
must exist and be hashes, or the 'save_on_exit' component will not be
created and fail silently. This is a common pitfall.

Variable names
~~~~~~~~~~~~~~

A variable name must start with a letter or underscore and can be followed
by any number of letters, numbers and underscores. Case is significative,
so aaa and AAA and aAa are different symbols.

Variable scope
~~~~~~~~~~~~~~

By default, non-existent assigned variables are created as global symbols.
Though they are useful, it's not a good programming practice to have all
variables as global, so local variables can be used. They are defined by
using the local directive:

 local a;	/* creates the local variable a, with NULL value */
 local b = 100;	/* creates the local variable b, with a value of 100 */

Local variables have its life limited to the subroutine where they are
defined or, if defined inside a block, limited to that block. Inner
variables obscure more global ones, as in the example:

 var = 6;	/* global variable var, with a value of 6 */
 
 {		/* start of block */
	local var = 10;			/* local variable var */
	print("var: ", var, "\n");	/* prints var: 10 */
	var = 20;			/* local var now has 20 */
	print("var: ", var, "\n");	/* prints var: 20 */
 }		/* end of block */
 
 print("var: ", var, "\n");		/* prints var: 6 */

Subroutine arguments are treated as local variables.

Conditional and looping constructs
----------------------------------

If
~~

Mpsl has the usual 'if' conditional construct. The condition can be any
mpsl expression, and the conditional code must be written between braces
if it's more than one instruction, just like in C.

 /* one instruction */
 if(a > b)
	do_something();
 
 /* more than one instruction (braces needed) */
 if(c == d)
 {
	do_this();
	do_that();
 }

'If' conditionals can also include an else instruction or block:

 if(tab_size == 8)
	print("You are sane\n");
 else
	print("Weirdo!\n");

While
~~~~~

'While' conditionals are exactly as you suppose they are:

 while(player_is_alive)
 {
	/* game loop */
	move_player();
	move_baddies();
	update_counter();
 }

As in 'if', the loop body needs braces if it has more than one instruction.

Foreach
~~~~~~~

'Foreach' is a special conditional to do something with all elements of an
array. The usual construction is as follows:

 /* week days */
 weekdays = [ 'monday', 'tuesday', 'wednesday', 'thurday', 'friday' ];
 
 foreach(w, weekdays)
	print("I hate ", w, "s\n");

Each value of the array will be assigned to the variable and the loop body
executed. As always, the variable is created if it doesn't exist.

Break
~~~~~

'While' and 'foreach' loops can be exited by using break, just as in C.

Builtin operators and functions
-------------------------------

Assignment
~~~~~~~~~~

Arithmetic
~~~~~~~~~~

Numeric comparison
~~~~~~~~~~~~~~~~~~

Boolean logic
~~~~~~~~~~~~~

Immediate operations
~~~~~~~~~~~~~~~~~~~~

Subroutines
-----------

Without arguments
~~~~~~~~~~~~~~~~~

With arguments
~~~~~~~~~~~~~~

Regular expressions
-------------------

File I/O
--------

----
Angel Ortega <angel@triptico.com>
