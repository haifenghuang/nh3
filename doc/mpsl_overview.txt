Mpsl overview
=============

 Angel Ortega <angel@triptico.com>

Syntax
------

Mpsl (Minimum Profit Scripting Language) is a programming language
concieved as an scripting engine for the Minimum Profit Text Editor,
though in can also be used as a general-purpose programming tool. An mpsl
program consists of a sequence of statements which run from top to bottom.
Loops, subroutines and other control structures allow you to jump around
within the code. It is a free-form language, meaning that you can format
and indent it however you like, as whitespace serves to separate tokens.

Mpsl borrows syntax and concepts from many languages: C, Perl, Java or
JavaScript. Statements end in a semi-colon, blocks are enclosed between {
and } (curly brackets).

Comments
~~~~~~~~

Text enclosed between /* and */ is ignored, as in C. It can span multiple
lines.

Strings
~~~~~~~

Strings are enclosed around single or double quotes:

 print("This a string");
 print('This is also a string');

However, double quotes give special treatment to backslash-escaped
characters, also as in C:

 print("Hello, world\n");	/* ends with a new line */
 print('Hello, World\n');	/* prints Hello, World\n literally */

Subroutine calls
~~~~~~~~~~~~~~~~

Function and subroutine calls must enclose its arguments between
parentheses, and separated by commas:

 print("This is ", 'a list ', "of ", 5, " arguments\n");

Parentheses are needed even if a function has no arguments.

True and false
~~~~~~~~~~~~~~

The number 0, the strings '0' and '' and NULL are all false as boolean
values. Any other value is considered true.

Variables and data types
------------------------

Data types in mpsl match the mpdm (Minimum Profit Data Manager) single,
array and hash values. They are very similar to Perl ones. However,
variable names don't have a prefix indicating its type as in Perl; they
can hold any type.

Variables need not be declared (unless for local values, see below); they
are created on assignation.

Scalars
~~~~~~~

A scalar represents a single value. They can be strings, integers or
floating point numbers, and they will be converted as required.

 fruit = "pear";
 months = 12;
 pi = 3.1416;

There are other types of scalar values, as file descriptors and executable
values; they will be treated later.

Scalar assignation is always by value; by doing

 a = 100; b = a; b = 5;

The a variable still holds its original value of 100.

Arrays
~~~~~~

An array represents a list of values. Arrays are zero-indexed. Each
element of an array can be of any type (scalar, array, or hash). Array
size is dynamic and can grow or shrink at the programmer's wish.

 workdays = [ 'monday', 'tuesday', 'wednesday', 'thursday', 'friday' ];
 
 print(workdays[0], "\n");	/* prints monday */
 
 heterogeneous_array = [ 1, "string", NULL, function(), workdays ];

Array assignation is always by reference; by doing

 a = [ 10, 20, 30 ]; b = a; b[0] = 100;

The value for the element a[0] is also 100; a and b both point to the same
array. A special-purpose function, clone(), can be used if you want them
to be different values.

Arrays grow when assigned to an out-of-bounds subscript:

 ary = [ 0, 1, 2, 3 ];
 print("size: ", size(ary), "\n");	/* prints size: 4 */
 ary[100] = 100;
 print("size: ", size(ary), "\n");	/* prints size: 101 */

Hashes
~~~~~~

A hash, or associative array, represents a set of key/value pairs. Keys and
values can be of any type (scalar, array or hash). However, keys are
usually scalar values, in particular strings.

 en2es_workdays = {
	"monday"	=>	"lunes",
	"tuesday"	=>	"martes",
	"wednesday"	=>	"miércoles",
	"thursday"	=>	"jueves",
	"friday"	=>	"viernes"
	};
 
 print(en2es_workdays['monday'], "\n"); /* prints lunes */
 
 week = {
	"workdays"	=>	workdays,
	"weekend"	=>	[ 'saturday', 'sunday' ]
	};

Hash definitions *must* use the => to mark key/value pairs.

Hash assignation is always by reference, as in arrays (in fact, hashes are
just a special case of array).

Compact access to hash members
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hashes can, and ofter are, used as records. Given the following hash of
hashes:

 app = {};
 app['config'] = {};
 app['config']['save_on_exit'] = 1;

The save_on_exit component can also be accessed by using:

 app.config.save_on_exit = 1;

Please note that variables are *not* automatically created unless the path
to them already exist; so 'app' and 'app.config' must exist and be hashes,
or the 'save_on_exit' component will not be created and fail silently.
This is a common pitfall.

Variable names
~~~~~~~~~~~~~~

A variable name must start with a letter or underscore and can be followed
by any number of letters, numbers and underscores. Case is significative,
so aaa and AAA and aAa are different symbols.

Variable scope
~~~~~~~~~~~~~~

By default, non-existent assigned variables are created as global symbols.
Though they are useful, it's not a good programming practice to have all
variables as global, so local variables can be used. They are defined by
using the local directive:

 local a;	/* creates the local variable a, with NULL value */
 local b = 100;	/* creates the local variable b, with a value of 100 */

Local variables have its life limited to the subroutine where they are
defined or, if defined inside a block, limited to that block. Inner
variables obscure more global ones, as in the example:

 var = 6;	/* global variable var, with a value of 6 */
 
 {		/* start of block */
	local var = 10;			/* local variable var */
	print("var: ", var, "\n");	/* prints var: 10 */
	var = 20;			/* local var now has 20 */
	print("var: ", var, "\n");	/* prints var: 20 */
 }		/* end of block */
 
 print("var: ", var, "\n");		/* prints var: 6 */

Subroutine arguments are treated as local variables.

Conditional and looping constructs
----------------------------------

If
~~

Mpsl has the usual 'if' conditional construct. The condition can be any
mpsl expression, and the conditional code must be written between braces
if it's more than one instruction, just like in C.

 /* one instruction */
 if(a > b)
	do_something();
 
 /* more than one instruction (braces needed) */
 if(c == d)
 {
	do_this();
	do_that();
 }

'If' conditionals can also include an else instruction or block:

 if(tab_size == 8)
	print("You are sane\n");
 else
	print("Weirdo!\n");

While
~~~~~

'While' conditionals are exactly as you suppose they are:

 while(player_is_alive)
 {
	/* game loop */
	move_player();
	move_baddies();
	update_counter();
 }

As in 'if', the loop body needs braces if it has more than one instruction.

Foreach
~~~~~~~

'Foreach' is a special conditional to do something with all elements of an
array. The usual construction is as follows:

 /* week days */
 weekdays = [ 'monday', 'tuesday', 'wednesday', 'thurday', 'friday' ];
 
 foreach(w, weekdays)
	print("I hate ", w, "s\n");

Each value of the array will be assigned to the variable and the loop body
executed. As always, the variable is created if it doesn't exist.

Break
~~~~~

Exit from 'While' and 'foreach' loops can be forced by using 'break', just
as in C.

Builtin operators
-----------------

Assignment
~~~~~~~~~~

To assign a value to a variable, use the = operator. Remember that scalars
are always assigned by value, and multiple values (arrays and hashes) are
always assigned by reference (in case you need a copy of a multiple value,
use the clone() function).

Arithmetic
~~~~~~~~~~

The usual +, -, *, / and % operators are used for addition, substraction,
multiply, divide and modulo, as always. Operands for the modulo operator
are treated as integers, and for the rest of them, as real numbers.
Operator precedence are like in C; you can always use parentheses to
explicitly force your desired precedence.

Numeric comparison
~~~~~~~~~~~~~~~~~~

The usual == (equality), != (inequality), > (greater than), < (less than),
>= (greater or equal than) and <= (less or equal than) operands can be
used.

Strings
~~~~~~~

The eq operator is used for testing string equality, and ~ is used for
concatenating strings.

Mpsl's scalar values are used for both string and numerical values, so (as
in Perl) the string and numeric comparison operators must be different:

 a = 0; b = 0.0;
 if(a == b) { /* this is truth */ }
 if(a eq b) { /* this is false */ }

Boolean logic
~~~~~~~~~~~~~

As in C, && (logical and) and || (logical or) are used. They don't return
just a boolean value, but the value that matches the condition, so that
you can do:

 a = 0; b = 100;
 c = a || b;		/* c ends with a value of 100 */
 c = a && b;		/* c ends with a value of 0 */
 a = 50;
 c = a || b;		/* c ends with a value of 50 */
 c = a && b;		/* c ends with a value of 100 */

Mpsl lacks a ternary conditional operator (as the ? : one in C), but it
can be easily simulated with && and || operators:

 /* assigns to c the greatest of a and b */
 c = a > b && a || b;

There is also the ! operator, that negates a condition.

Immediate operators
~~~~~~~~~~~~~~~~~~~

Immediate operators act directly over variables. The most usual examples
are the unary ++ and --, that are used as in C.

 a = 100;
 a++;		/* a's value is now 101 */
 a--;		/* back to 100 */

Also as in C, this operators can be used as prefixes or suffixes, giving
the following result:

 a = 100;
 b = a++;	/* b's value is 100, a's value is 101 */
 c = ++a;	/* c's and a's value is both 102 */

The well known binary +=, -=, *=, /= and %= also exist:

 a += 25;	/* adds 25 to a */

Subroutines
-----------

Subroutines (also called functions) are created with the 'sub' keyword:

 sub main_loop
 {
	while(!exit_requested)
	{
		local o;
 
		o = get_option();
		process_option(k);
		draw_screen();
	}
 }

Subroutines can also accept arguments:

 sub process_option(o)
 {
	if(o == -1)
		exit_requested=1;
	else
		print("Option is ", o, "\n");
 }

Subroutine arguments can be used as local variables (in fact, that is exactly
what they are).

As in assignations, when you pass a multiple value (arrays and hashes) as
an argument to a subroutine, it's always done by reference, so modifying
it will change the original value:

 sub dequeue(queue) { local a = apop(queue); do_something_with(a); }
 
 my_q = [ 10, 20, 30 ];
 dequeue(my_q);		/* on exit, my_q will contain only [ 10, 20 ] */

As every code fragment in mpsl, subroutines always return a value. By
default, a subroutine returns the result of the last operation:

 sub avg(a, b) { a += b; a /= 2; }

The value to be returned can be explicitly expressed by using the 'return'
keyword, that can also be used to break execution flow:

 sub div(a, b)
 {
	if(b == 0)
	{
		print("Invalid value for b.\n");
		return(0);
	}
 
	return(a / b);
 }

When calling a subroutine, parentheses are always mandatory, even if it
has no arguments. If a subroutine is referenced without its arguments,
it's not called, but a pointer to it returned instead:

 sub sum(a, b) { return(a + b); }
 
 a = sum(10, 20);	/* a == 30 */
 b = sum;		/* b has a pointer to the sum subroutine */
 
 c = b(20, 30);		/* c == 50, same as calling sum(20, 30) */

The 'sub' directive can also be used as an rvalue to define anonymous
subroutines. So, the following can be done:

 on_exit_subs = [];
 apush(on_exit_subs, sub { print("Close files\n"); } );
 apush(on_exit_subs, sub { print("Clean up memory\n"); } );
 apush(on_exit_subs, sub { print("Other stuff\n"); } );
 
 /* exiting; calling all functions stored in on_exit_subs */
 foreach(f, on_exit_subs) f();

Anonymous functions can also accept arguments:

 math_ops = [
 	sub (a, b) { print(a, " + ", b, ": ", a + b, "\n"); },
 	sub (a, b) { print(a, " - ", b, ": ", a - b, "\n"); },
 	sub (a, b) { print(a, " * ", b, ": ", a * b, "\n"); },
 	sub (a, b) { print(a, " / ", b, ": ", a / b, "\n"); }
 ];
 
 foreach(f, math_ops) f(10, 20);

This kind of anonymous subroutines are commonly used as callbacks. The
following examples use the two-argument version of asort() to sort arrays
in different ways:

 /* reverse-sort the array (comparing each element backwards) */
 sorted_ary = asort(unsorted_ary, sub (a, b) { cmp(b, a); } );
 
 /* numeric sort (instead of plain ASCII) */
 sorted_ary = asort(unsorted_ary, sub (a, b) { a - b; } );

Subroutines are defined in execution time and *not* in compilation time.
This means that you can redefine a subroutine whenever you want, but be
aware that you can't use it before the 'sub' instruction has been
executed. This is a common pitfall:

 /* call a function before it exists: error */
 print("Average for 2 and 3 is ", avg(2, 3), "\n");
 
 sub avg(a, b) { a += b; a /= 2; }
 
 /* now you can use it */
 print("Average for 4 and 5 is ", avg(4, 5), "\n");

It's easier to see subroutine definitions as an assignation of a code
block to a variable: you would never access a variable before assigning a
value to it.

Regular expressions
-------------------

File I/O
--------

----
Angel Ortega <angel@triptico.com>
