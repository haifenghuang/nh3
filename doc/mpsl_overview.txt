MPSL overview
=============

 Angel Ortega <angel@triptico.com>

Syntax
------

MPSL (Minimum Profit Scripting Language) is a programming language
concieved as an scripting engine for the Minimum Profit Text Editor,
though it can also be used as a general-purpose programming tool. An MPSL
program consists of a sequence of statements which run from top to bottom.
Loops, subroutines and other control structures allow you to jump around
within the code. It is a free-form language, meaning that you can format
and indent it however you like, as whitespace serves to separate tokens.

MPSL borrows syntax and concepts from many languages: C, Perl, Java or
JavaScript. Statements end in a semi-colon, blocks are enclosed between {
and } (curly brackets).

Comments
~~~~~~~~

Text enclosed between /* and */ is ignored, as in C. It can span multiple
lines.

Strings
~~~~~~~

Strings are enclosed around single or double quotes:

 print("This a string");
 print('This is also a string');

However, double quotes give special treatment to backslash-escaped
characters, also as in C:

 print("Hello, world\n");	/* ends with a new line */
 print('Hello, World\n');	/* prints Hello, World\n literally */

Subroutine calls
~~~~~~~~~~~~~~~~

Function and subroutine calls must enclose its arguments between
parentheses, and separate them by commas:

 print("This is ", 'a list ', "of ", 5, " arguments\n");

Parentheses are needed even if a function has no arguments.

True and false
~~~~~~~~~~~~~~

The number 0, the strings '0' and '' and NULL are all false as boolean
values. Any other value is considered true.

Variables and data types
------------------------

Data types in MPSL match the mpdm (Minimum Profit Data Manager) single,
array and hash values. They are very similar to Perl ones. However,
variable names don't have a prefix indicating its type as in Perl; they
can hold any type.

Variables need not be declared (unless for local values, see below); they
are created on assignation.

Scalars
~~~~~~~

A scalar represents a single value. They can be strings, integers or
floating point numbers, and they will be converted as required.

 fruit = "pear";
 months = 12;
 pi = 3.1416;

There are other types of scalar values, as file descriptors and executable
values; they will be treated later.

Scalar assignation is always by value; by doing

 a = 100; b = a; b = 5;

The a variable still holds its original value of 100.

Arrays
~~~~~~

An array represents a list of values. Arrays are zero-indexed. Each
element of an array can be of any type (scalar, array, or hash). Array
size is dynamic and can grow or shrink at the programmer's wish.

 workdays = [ 'monday', 'tuesday', 'wednesday', 'thursday', 'friday' ];
 
 print(workdays[0], "\n");	/* prints monday */
 
 heterogeneous_array = [ 1, "string", [ 1, 2, 3 ], NULL, function(), workdays ];

Array assignation is always by reference; by doing

 a = [ 10, 20, 30 ]; b = a; b[0] = 100;

The value for the element a[0] is also 100; a and b both point to the same
array. A special-purpose function, clone(), can be used if you want them
to be different values.

Arrays grow when assigned to an out-of-bounds subscript:

 ary = [ 0, 1, 2, 3 ];
 print("size: ", size(ary), "\n");	/* prints size: 4 */
 ary[100] = 100;
 print("size: ", size(ary), "\n");	/* prints size: 101 */

The range operator can be used to populate an array with consecutive,
integer values, as in the example:

 ary = [ 1 .. 100 ];	/* ary contains 100 elements, from 1 to 100 */

Hashes
~~~~~~

A hash, or associative array, represents a set of key/value pairs. Keys and
values can be of any type (scalar, array or hash). However, keys are
usually scalar values, in particular strings.

 en2es_workdays = {
	'monday'	=>	'lunes',
	'tuesday'	=>	'martes',
	'wednesday'	=>	'miércoles',
	'thursday'	=>	'jueves',
	'friday'	=>	'viernes'
	};
 
 print(en2es_workdays['monday'], "\n"); /* prints lunes */
 
 week = {
	'workdays'	=>	workdays,
	'weekend'	=>	[ 'saturday', 'sunday' ]
	};

Hash definitions *must* use the => to mark key/value pairs.

Hash assignation is always by reference, as in arrays (in fact, hashes are
just a special case of array).

Compact access to hash members
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hashes can, and ofter are, used as records. Given the following hash of
hashes:

 app = {};
 app['config'] = {};
 app['config']['save_on_exit'] = 1;

The save_on_exit component can also be accessed by using:

 app.config.save_on_exit = 1;

Please note that variables are *not* automatically created unless the path
to them already exist; so 'app' and 'app.config' must exist and be hashes,
or the 'save_on_exit' component will not be created and fail silently.
This is a common pitfall.

Variable names
~~~~~~~~~~~~~~

A variable name must start with a letter or underscore and can be followed
by any number of letters, numbers and underscores. Case is significative,
so aaa and AAA and aAa are different symbols.

Variable scope
~~~~~~~~~~~~~~

By default, non-existent assigned variables are created as global symbols.
Though they are useful, it's not a good programming practice to have all
variables as global, so local variables can be used. They are defined by
using the local directive:

 local a;	/* creates the local variable a, with NULL value */
 local b = 100;	/* creates the local variable b, with a value of 100 */

Local variables have its life limited to the subroutine where they are
defined or, if defined inside a block, limited to that block. Inner
variables obscure more global ones, as in the example:

 var = 6;	/* global variable var, with a value of 6 */
 
 {		/* start of block */
	local var = 10;			/* local variable var */
	print("var: ", var, "\n");	/* prints var: 10 */
	var = 20;			/* local var now has 20 */
	print("var: ", var, "\n");	/* prints var: 20 */
 }		/* end of block */
 
 print("var: ", var, "\n");		/* prints var: 6 */

Subroutine arguments are treated as local variables.

Conditional and looping constructs
----------------------------------

If
~~

MPSL has the usual 'if' conditional construct. The condition can be any
MPSL expression, and the conditional code must be written between braces
if it's more than one instruction, just like in C.

 /* one instruction */
 if(a > b)
	do_something();
 
 /* more than one instruction (braces needed) */
 if(c == d)
 {
	do_this();
	do_that();
 }

'If' conditionals can also include an else instruction or block:

 if(tab_size == 8)
	print("You are sane\n");
 else
	print("Weirdo!\n");

While
~~~~~

'While' conditionals are exactly as you suppose they are:

 while(player_is_alive)
 {
	/* game loop */
	move_player();
	move_baddies();
	update_counter();
 }

As in 'if', the loop body needs braces if it has more than one instruction.

Foreach
~~~~~~~

'Foreach' is a special conditional to do something with all elements of an
array. The usual construction is as follows:

 /* week days */
 weekdays = [ 'monday', 'tuesday', 'wednesday', 'thurday', 'friday' ];
 
 foreach(w, weekdays)
	print("I hate ", w, "s\n");

Each value of the array will be assigned to the variable and the loop body
executed. As always, the variable is created if it doesn't exist.

Break
~~~~~

Exit from 'while' and 'foreach' loops can be forced by using 'break', just
as in C.

Builtin operators
-----------------

Assignment
~~~~~~~~~~

To assign a value to a variable, use the = operator. Remember that scalars
are always assigned by value, and multiple values (arrays and hashes) are
always assigned by reference (in case you need a copy of a multiple value,
use the clone() function).

Arithmetic
~~~~~~~~~~

The usual +, -, *, / and % operators are used for addition, substraction,
multiply, divide and modulo, as always. Operands for the modulo operator
are treated as integers, and for the rest of them, as real numbers.
Operator precedence are like in C; you can always use parentheses to
explicitly force your desired precedence.

Numeric comparison
~~~~~~~~~~~~~~~~~~

The usual == (equality), != (inequality), > (greater than), < (less than),
>= (greater or equal than) and <= (less or equal than) operands can be
used.

Strings
~~~~~~~

The 'eq' operator is used for testing string equality, 'ne' for the
opposite and ~ is used for concatenating strings.

MPSL's scalar values are used for both string and numerical values, so (as
in Perl) the string and numeric comparison operators must be different:

 a = 0; b = 0.0;
 if(a == b) { /* this is truth */ }
 if(a eq b) { /* this is false */ }

Boolean logic
~~~~~~~~~~~~~

As in C, && (logical and) and || (logical or) are used. They don't return
just a boolean value, but the value that matches the condition, so that
you can do:

 a = 0; b = 100;
 c = a || b;		/* c ends with a value of 100 */
 c = a && b;		/* c ends with a value of 0 */
 a = 50;
 c = a || b;		/* c ends with a value of 50 */
 c = a && b;		/* c ends with a value of 100 */

MPSL lacks a ternary conditional operator (as the ? : one in C), but it
can be easily simulated with && and || operators:

 /* assigns to c the greatest of a and b */
 c = a > b && a || b;

There is also the ! operator, that negates a condition.

Immediate operators
~~~~~~~~~~~~~~~~~~~

Immediate operators act directly over variables. The most usual examples
are the unary ++ and --, that are used as in C.

 a = 100;
 a++;		/* a's value is now 101 */
 a--;		/* back to 100 */

Also as in C, this operators can be used as prefixes or suffixes, giving
the following result:

 a = 100;
 b = a++;	/* b's value is 100, a's value is 101 */
 c = ++a;	/* c's and a's value is both 102 */

The well known binary +=, -=, *=, /= and %= also exist:

 a += 25;	/* adds 25 to a */

Subroutines
-----------

Subroutines (also called functions) are created with the 'sub' keyword:

 sub main_loop
 {
	while(!exit_requested)
	{
		local o;
 
		o = get_option();
		process_option(k);
		draw_screen();
	}
 }

Subroutines can also accept arguments:

 sub process_option(o)
 {
	if(o == -1)
		exit_requested=1;
	else
		print("Option is ", o, "\n");
 }

Subroutine arguments can be used as local variables (in fact, that is exactly
what they are).

As in assignations, when you pass a multiple value (arrays and hashes) as
an argument to a subroutine, it's always done by reference, so modifying
it will change the original value:

 sub dequeue(queue) { local a = pop(queue); do_something_with(a); }
 
 my_q = [ 10, 20, 30 ];
 dequeue(my_q);		/* on exit, my_q will contain only [ 10, 20 ] */

As every code fragment in MPSL, subroutines always return a value. By
default, a subroutine returns the result of the last operation:

 sub avg(a, b) { a += b; a /= 2; }

The value to be returned can be explicitly expressed by using the 'return'
keyword, that can also be used to break execution flow:

 sub div(a, b)
 {
	if(b == 0)
	{
		print("Invalid value for b.\n");
		return(0);
	}
 
	return(a / b);
 }

When calling a subroutine, parentheses are always mandatory, even if it
has no arguments. If a subroutine is referenced without its arguments,
it's not called, but a pointer to it returned instead:

 sub sum(a, b) { return(a + b); }
 
 a = sum(10, 20);	/* a == 30 */
 b = sum;		/* b has a pointer to the sum subroutine */
 
 c = b(20, 30);		/* c == 50, same as calling sum(20, 30) */

The 'sub' directive can also be used as an rvalue to define anonymous
subroutines. So, the following can be done:

 on_exit_subs = [];
 push(on_exit_subs, sub { print("Close files\n"); } );
 push(on_exit_subs, sub { print("Clean up memory\n"); } );
 push(on_exit_subs, sub { print("Other stuff\n"); } );
 
 /* exiting; calling all functions stored in on_exit_subs */
 foreach(f, on_exit_subs) f();

Anonymous functions can also accept arguments:

 math_ops = [
 	sub (a, b) { print(a, " + ", b, ": ", a + b, "\n"); },
 	sub (a, b) { print(a, " - ", b, ": ", a - b, "\n"); },
 	sub (a, b) { print(a, " * ", b, ": ", a * b, "\n"); },
 	sub (a, b) { print(a, " / ", b, ": ", a / b, "\n"); }
 ];
 
 foreach(f, math_ops) f(10, 20);

This kind of anonymous subroutines are commonly used as callbacks. The
following examples use the two-argument version of asort() to sort arrays
in different ways:

 /* reverse-sort the array (comparing each element backwards) */
 sorted_ary = sort(unsorted_ary, sub (a, b) { cmp(b, a); } );
 
 /* numeric sort (instead of plain ASCII) */
 sorted_ary = sort(unsorted_ary, sub (a, b) { a - b; } );

Subroutines are defined in execution time and *not* in compilation time.
This means that you can redefine a subroutine whenever you want, but be
aware that you can't use it before the 'sub' instruction has been
executed. This is a common pitfall:

 /* call a function before it exists: error */
 print("Average for 2 and 3 is ", avg(2, 3), "\n");
 
 sub avg(a, b) { a += b; a /= 2; }
 
 /* now you can use it */
 print("Average for 4 and 5 is ", avg(4, 5), "\n");

It's easier to see subroutine definitions as an assignation of a code
block to a variable: you would never access a variable before assigning a
value to it.

Type-checking functions
-----------------------

There are three functions to test a type of a value: is_exec(), is_hash()
and is_array(). They return true if the tested value is executable, a hash
or an array, respectively.

On this implementation, executable and hash values are also arrays, so if
you need to act differently on the type of a value, the correct order is
is_exec(), is_hash() and is_array(), as in the following example:

 if(is_exec(v)) { print("v is executable\n"); }
 else
 if(is_hash(v)) { print("v is a hash with ", hsize(v), " pairs\n"); }
 else
 if(is_array(v) { print("v is an array with ", size(v), " elements\n"); }
 else
 	print("v is a scalar\n");

Regular expression matching
---------------------------

Regular expression matching is done with the regex() function. In the simpler
of its forms, it can be used to test if a string matches:

 /* hours, minutes, seconds */
 v = "07:55:35";
 
 if(regex("/^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$/", v))
 	print("The v variable contains a valid time\n");

The regular expression can contain flags; those are 'i', for case
insensitiveness, or 'm', to treat the string as a multiline one (i.e., one
containing \n characters), where the special ^ and $ markup match beginning
and end of lines and not the beginning or end of the string.

Regex() returns the matched string.

 v = "The value of PI is 3.1416, more or less";
 
 pi = regex("/[0-9]+\.[0-9]+/", v);

If regex() is called without arguments, it returns the last match as an array
of two elements; the first contain the offset of the matched strings, and the
second, the size in characters of it. If last match was unsuccessful, NULL is
returned.

 /* get the match of the previous example */
 coords = regex();
 
 /* prints 19:6 */
 print(coords[0], ":", coords[1], "\n");

Regex() can include an optional third argument, the offset where the regular
expression matching must start (instead of 0, the beginning of the string).
This can be used to extract many values from the same string:

 /* lets extract all numbers in the following string: */
 s = "There is 10 and 35 and 42 in the number 103542!";
 offset = 0;
 
 while(n = regex("/[0-9]+/", s, offset))
 {
 	local c;
 
 	/* print result */
 	print(n, "\n");
 
 	/* get the coordinates */
 	c = regex();
 
 	/* start from there (previous match offset + size) */
 	offset += c[0] + c[1];
 }

For more complex situations, the first argument of regex() can be an array
of regular expressions (instead of a string). Those expressions will tried
one after the other on the string, each one using the offset returned by
the previous one. If all of them are matched, an array with the matched strings
is returned.

 /* match pairs of key=value commands, with many variants */
 v1 = "key1=value1";
 v2 = " KEY2 = value2";
 v3 = "key3=333  ";
 
 /* array regex: a regex for each part */
 r = regex([ "/\s*/",        /* possible leading blanks (0) */
             "/[a-z0-9]+/i", /* the key (1) */
             "/\s*=\s*/",    /* optional blanks, the = , more blanks (2) */
             "/[a-z0-9]+/i"  /* the value (3) */
           ], v1);
 
 if(r != NULL)
 {
 	/* the key is the element #1 and the value the #3 */
 	key = r[1];
 	value = r[3];
 }

Regular expression substitutions
--------------------------------

To be written.

File I/O
--------

To be written.

Special symbols
---------------

ARGV
~~~~

Stores the command line arguments sent to the main() function.

INC
~~~

Holds an array of paths on disk where source files will be searched
for by the load() command.

ERROR
~~~~~

Stores the last error message.

MPSL.VERSION
~~~~~~~~~~~~

Stores the MPSL version as a string.

STDIN, STDOUT, STDERR
~~~~~~~~~~~~~~~~~~~~~

The famous standard file descriptors.

----
Angel Ortega <angel@triptico.com> - $Date$
